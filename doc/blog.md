# 造轮子系列之小字符串类 tinystring

## 背景原由

常听 C++ 的大佬们说，标准库的 `std::string` 并不好用，所以也萌生了自己定制个字
符串类。根据近几年的工作经验来看，似乎从未用到过宽字符串，而且大多情况下用到的
字符串都比较短，或者说用到短字符串的概率比长字符串大得多。所以就想到写这么个字
符串类，专注小字符串优化。

## 概念说明

我们一般提到的小字符串，是个较模糊的概念，长度多小的才算小字符串呢？在具体实现
中需要给出明确的定义。

故这里定义的“小字符串”，是指长度也可用一个字节来表示的字符串，也就是 `0xFF`
255 以内的字符串。兼容 C 的字符串要求其开尾须以 `\0` 空字符结尾，所以在申请的
字符串内存空间中至少有一个字节的余量，那我们就可以利用这末尾的余量字节才存储其
当前长度。当然如果已经填满的字符串，即 `size == capacity` 时，那末尾字节还得存
`\0` ，这就是所谓“满字符串”的状态，并且也可与空字符串的状态区别开来，因为空
字符串时其首字节就该是 `\0` 。

当字符串长度增长到 256 以上怎么办？总不能直接拒绝工作抛出异常吧，为了能容忍偶
尔（或经常）超纲的字符串，就对以上小字符串的表示法进行自然扩展。既然一个字节无
法表达其长度（与容量），那就用两个字节吧。所以称能用两个尾字节表示其长度的字符
串为“中字符串”，要用四个尾字节表示其长度的称为“长字符串”。四个字节已经能表
达最大 4G 的字符串了，这也是 32 位系统 `size_t` 所能表达的范围，当然比 64 位系
统的 `size_t` 还是小许多。不过真有需求处理 4G 以上的字符串，那显然就不该是小字
符串类库所该操心的事了。

## 具体实现

请参考 https://github.com/lymslive/tinystring 。

主要实现了两大类字符串，一类是定容小字符串，如（在命名空间 `utd` 下）：

* `str16_t`
* `str32_t`
* `str64_t` 
* `str128_t`
* `str256_t`

顾名思义， `str16_t` 类总大小为 16 字节，可表示长度 15 以下的字符串，至少还保
留一字节存储 `\0` 。

另一类是统一的可自动扩容的字符串，命名为 `ustring` 。如在栈内定义 `ustring` 对
象，它也是 16 字节大小，并且开始表现得如 `str16_t` 一样。超过 15 长度后，才在
堆上申请空间存储字符串，而在原栈区保存其指针（还有额外空间可存容量）。在长度
小于 256 时，扩容策略是总大小翻倍，所以就相当于逐步升级指针指向 `str32_t`
`str64_t` `str128_t` 与 `str256_t` 。

当小字符串扩容到中长字符串后，其扩容策略略有不同，不再是总大小的指数翻倍（大约
是所需差额的两倍）。这功能算是“彩头”或“异常”，表明也能处理，但非设计本意。

一般情况下，也许只需用 `ustring` ，简捷方便，就像 `std::string` 那般使用。不过
在某些情况下，使用定容的小字符串如 `str128_t` 也可能提供便利。

（另注：目前并没有实现 `std::string` 的所有方法，比如 find 系，不过那些都比较
直接，有需要时再补充吧。）

此外为 `utd::ustring` 实现了配套的内存分配器 `allocator` ，专门为从 `str32_t` 到
`str256_t` 这四种规格的小字符串管理内存。当然，分配器作为模板参数，与字符串类
本身是可以相互独立的。
